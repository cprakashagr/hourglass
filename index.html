<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Hourglass">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="theme-color" content="#000000">
  <title>Hourglass</title>
  <style>
    *, *::before, *::after { box-sizing: border-box; }
    body, html {
      margin: 0; padding: 0;
      width: 100%; height: 100%;
      background: #000000;
      overflow: hidden;
      touch-action: none;
      -webkit-tap-highlight-color: transparent;
      font-family: -apple-system, BlinkMacSystemFont, "SF Pro Display", "Helvetica Neue", Arial, sans-serif;
      /* Extend into notch/dynamic island area */
      padding-top: env(safe-area-inset-top);
      padding-bottom: env(safe-area-inset-bottom);
    }
    #canvas-container {
      position: relative;
      width: 100vw; height: 100vh;
      background: #000000;
    }
    canvas {
      display: block; position: absolute;
      top: 0; left: 0;
      background: #000000;
    }
    #time-display {
      position: absolute;
      color: white; font-size: 2.2rem; font-weight: 200; letter-spacing: 1px;
      opacity: 0; transition: opacity 0.35s ease;
      pointer-events: none;
      text-shadow: 0 0 20px rgba(255,255,255,0.5);
      z-index: 20; text-align: center;
      left: 50%; transform: translateX(-50%);
    }
    #time-display.visible { opacity: 0.95; }
    #progress-display {
      position: absolute;
      color: white; font-size: 1.35rem; font-weight: 300; letter-spacing: 0.5px;
      opacity: 0; transition: opacity 0.25s ease;
      pointer-events: none;
      text-shadow: 0 0 16px rgba(255,255,255,0.45);
      z-index: 20; text-align: center;
      left: 50%; transform: translateX(-50%);
      white-space: nowrap;
    }
    #progress-display.visible { opacity: 0.88; }
    #interaction-layer {
      position: absolute; top: 0; left: 0;
      width: 100%; height: 100%; z-index: 10;
    }
  </style>
</head>
<body>
<div id="canvas-container">
  <div id="time-display">10s</div>
  <div id="progress-display"></div>
  <canvas id="glassCanvas"></canvas>
  <div id="interaction-layer"></div>
</div>
<script>
const canvas           = document.getElementById('glassCanvas');
const ctx              = canvas.getContext('2d');
const interactionLayer = document.getElementById('interaction-layer');
const timeDisplay      = document.getElementById('time-display');
const progressDisplay  = document.getElementById('progress-display');

const MIN_TIME = 10;
const MAX_TIME = 3600;

let width, height, cx, cy;
let S = {};

let isDragging          = false;
let isRunning           = false;
let isShowingProgress   = false;
let duration            = 60;
let timeLeft            = 0;
let topFillLevel        = 0;
let initialTopFillLevel = 0;
let bottomFillLevel     = 0;
let lastTime            = 0;

let topParticles    = [];
let bottomParticles = [];
let flowParticles   = [];

// Max flow particles cap — prevents accumulation/lag
const MAX_FLOW = 120;

function init() {
  resize();
  createParticles();
  requestAnimationFrame(animate);
}

function resize() {
  width  = window.innerWidth;
  height = window.innerHeight;
  const dpr = window.devicePixelRatio || 1;
  canvas.width  = width  * dpr;
  canvas.height = height * dpr;
  canvas.style.width  = width  + 'px';
  canvas.style.height = height + 'px';
  ctx.scale(dpr, dpr);
  cx = width  / 2;
  cy = height / 2;

  const r      = Math.min(44, width * 0.115);
  const neckHW = width * 0.10;
  const bendH  = height * 0.16;
  const gap    = height * 0.019;

  // Neck break — how far inward from each tip the edge stroke stops.
  // Larger value = bigger transparent gap at the neck center.
  const neckBreak = neckHW * 0.55; // tips retract this much from the drawn endpoint

  S = {
    left: 0, right: width, top: 0, bottom: height,
    cx, cy, r, neckHW, bendH, gap, neckBreak,
    topShapeBottom:  cy - gap,
    bottomShapeTop:  cy + gap,
    topBendStart:    cy - gap - bendH,
    bottomBendStart: cy + gap + bendH,
  };

  timeDisplay.style.top    = ((cy - gap) * 0.38) + 'px';
  progressDisplay.style.top = (cy + gap + (height - cy - gap) * 0.45) + 'px';
}
window.addEventListener('resize', resize);

function createParticles() {
  topParticles = Array.from({ length: 160 }, () => ({
    size:    Math.random() * 35 + 24,
    opacity: Math.random() * 0.38 + 0.28,
    phase:   Math.random() * Math.PI * 2
  }));
  bottomParticles = Array.from({ length: 190 }, () => ({
    size:    Math.random() * 38 + 26,
    opacity: Math.random() * 0.38 + 0.28,
    phase:   Math.random() * Math.PI * 2
  }));
}

function formatTime(s) {
  s = Math.max(0, Math.round(s));
  if (s < 60) return s + "s";
  const m = Math.floor(s / 60);
  const sec = s % 60;
  return sec === 0 ? m + "m" : m + "m " + sec + "s";
}

function formatProgress() {
  const elapsed = Math.max(0, duration - timeLeft);
  return formatTime(elapsed) + " of " + formatTime(duration);
}

// ── PATH BUILDERS ─────────────────────────────────────────────────────────
// Strategy: straight outer edges get the full LED glow.
// Neck arm curves are drawn SEPARATELY with a fading gradient stroke.
// The two are never combined, so the glow can't bleed into the neck tips.

// Top half — STRAIGHT edges only (top, right side to bendStart, left side to bendStart, corners)
// No neck arms at all.
function buildTopStraightPath() {
  const { left, right, top, cx, r, topBendStart } = S;
  ctx.beginPath();
  ctx.moveTo(left + r, top);
  ctx.lineTo(right - r, top);
  ctx.arcTo(right, top, right, top + r, r);
  ctx.lineTo(right, topBendStart);
  // jump across — no arms drawn
  ctx.moveTo(left, topBendStart);
  ctx.lineTo(left, top + r);
  ctx.arcTo(left, top, left + r, top, r);
  ctx.lineTo(right - r, top); // close top visually
}

// Bottom half — STRAIGHT edges only
function buildBottomStraightPath() {
  const { left, right, bottom, cx, r, bottomBendStart } = S;
  ctx.beginPath();
  ctx.moveTo(right, bottomBendStart);
  ctx.lineTo(right, bottom - r);
  ctx.arcTo(right, bottom, right - r, bottom, r);
  ctx.lineTo(left + r, bottom);
  ctx.arcTo(left, bottom, left, bottom - r, r);
  ctx.lineTo(left, bottomBendStart);
}

// Top half closed — for clipping/filling only
function buildTopHalfPath() {
  const { left, right, top, cx, r, neckHW, topShapeBottom, topBendStart } = S;
  ctx.beginPath();
  ctx.moveTo(left + r, top);
  ctx.lineTo(right - r, top);
  ctx.arcTo(right, top, right, top + r, r);
  ctx.lineTo(right, topBendStart);
  ctx.bezierCurveTo(right, topShapeBottom, cx + neckHW, topShapeBottom, cx + neckHW, topShapeBottom);
  ctx.lineTo(cx - neckHW, topShapeBottom);
  ctx.bezierCurveTo(cx - neckHW, topShapeBottom, left, topShapeBottom, left, topBendStart);
  ctx.lineTo(left, top + r);
  ctx.arcTo(left, top, left + r, top, r);
  ctx.closePath();
}

// Bottom half closed — for clipping/filling
function buildBottomHalfPath() {
  const { left, right, bottom, cx, r, neckHW, bottomShapeTop, bottomBendStart } = S;
  ctx.beginPath();
  ctx.moveTo(cx - neckHW, bottomShapeTop);
  ctx.lineTo(cx + neckHW, bottomShapeTop);
  ctx.bezierCurveTo(cx + neckHW, bottomShapeTop, right, bottomShapeTop, right, bottomBendStart);
  ctx.lineTo(right, bottom - r);
  ctx.arcTo(right, bottom, right - r, bottom, r);
  ctx.lineTo(left + r, bottom);
  ctx.arcTo(left, bottom, left, bottom - r, r);
  ctx.lineTo(left, bottomBendStart);
  ctx.bezierCurveTo(left, bottomShapeTop, cx - neckHW, bottomShapeTop, cx - neckHW, bottomShapeTop);
  ctx.closePath();
}

// ── BACKGROUND ────────────────────────────────────────────────────────────

function drawBackground() {
  ctx.fillStyle = '#000000';
  ctx.fillRect(0, 0, width, height);
  ctx.save(); buildTopHalfPath();    ctx.fillStyle = '#000000'; ctx.fill(); ctx.restore();
  ctx.save(); buildBottomHalfPath(); ctx.fillStyle = '#000000'; ctx.fill(); ctx.restore();
}

// ── GLASS EDGES ───────────────────────────────────────────────────────────

// Full LED glow — only called on straight edge paths (never neck arms)
function strokeGlowEdge(pathFn) {
  ctx.save();
  pathFn();
  ctx.shadowBlur  = 100;
  ctx.shadowColor = 'rgba(160,210,255,0.60)';
  ctx.strokeStyle = 'rgba(0,0,0,0)';
  ctx.lineWidth   = 3;
  ctx.stroke();

  pathFn();
  ctx.shadowBlur  = 55;
  ctx.shadowColor = 'rgba(255,255,255,0.85)';
  ctx.strokeStyle = 'rgba(0,0,0,0)';
  ctx.lineWidth   = 2.5;
  ctx.stroke();

  pathFn();
  ctx.shadowBlur  = 18;
  ctx.shadowColor = 'rgba(255,255,255,1.0)';
  ctx.strokeStyle = 'rgba(255,255,255,0.95)';
  ctx.lineWidth   = 1.8;
  ctx.stroke();

  pathFn();
  ctx.shadowBlur  = 4;
  ctx.shadowColor = 'rgba(255,255,255,1.0)';
  ctx.strokeStyle = 'rgba(255,255,255,1.0)';
  ctx.lineWidth   = 0.8;
  ctx.stroke();

  ctx.shadowBlur = 0;
  ctx.restore();
}

// Draw one neck arm with a gradient stroke fading from full glow at bendStart → invisible at neckY.
// Uses multiple passes so the glow itself also fades, not just the line opacity.
function drawNeckArm(x0, y0, cpX, cpY, x1, y1, glowStrength) {
  // glowStrength 0..1 — lets bend-start end match the straight edge brightness
  ctx.save();
  ctx.lineCap = 'round';

  // We approximate the bezier with a linear gradient from (x0,y0) to (x1,y1)
  const grLine = ctx.createLinearGradient(x0, y0, x1, y1);
  grLine.addColorStop(0,    `rgba(255,255,255,${0.95 * glowStrength})`);
  grLine.addColorStop(0.35, `rgba(255,255,255,${0.55 * glowStrength})`);
  grLine.addColorStop(0.70, `rgba(255,255,255,${0.18 * glowStrength})`);
  grLine.addColorStop(1,    'rgba(255,255,255,0.00)');

  const grGlow = ctx.createLinearGradient(x0, y0, x1, y1);
  grGlow.addColorStop(0,    `rgba(255,255,255,${0.80 * glowStrength})`);
  grGlow.addColorStop(0.35, `rgba(255,255,255,${0.35 * glowStrength})`);
  grGlow.addColorStop(0.70, `rgba(255,255,255,${0.08 * glowStrength})`);
  grGlow.addColorStop(1,    'rgba(255,255,255,0.00)');

  // Pass 1 — soft glow halo (medium width)
  ctx.shadowBlur  = 30;
  ctx.shadowColor = `rgba(200,230,255,${0.50 * glowStrength})`;
  ctx.strokeStyle = grGlow;
  ctx.lineWidth   = 4;
  ctx.beginPath();
  ctx.moveTo(x0, y0);
  ctx.bezierCurveTo(cpX, cpY, x1, y1, x1, y1);
  ctx.stroke();

  // Pass 2 — crisp bright line
  ctx.shadowBlur  = 12;
  ctx.shadowColor = `rgba(255,255,255,${0.80 * glowStrength})`;
  ctx.strokeStyle = grLine;
  ctx.lineWidth   = 1.6;
  ctx.beginPath();
  ctx.moveTo(x0, y0);
  ctx.bezierCurveTo(cpX, cpY, x1, y1, x1, y1);
  ctx.stroke();

  ctx.shadowBlur = 0;
  ctx.restore();
}

// Draw all four neck arms (2 per half) with fading glow
function drawNeckArms() {
  const { left, right, cx, neckHW, neckBreak } = S;

  // Top half arms — fade toward topShapeBottom
  const tY   = S.topShapeBottom;
  const tEnd = S.topBendStart;
  const tBRx = cx + neckHW + neckBreak; // right arm tip X
  const tBLx = cx - neckHW - neckBreak; // left arm tip X

  // Top-right arm: from (right, topBendStart) bezier to (tBRx, tY)
  drawNeckArm(right, tEnd,  right, tY,  tBRx, tY,  1.0);
  // Top-left arm: from (left, topBendStart) bezier to (tBLx, tY)
  drawNeckArm(left,  tEnd,  left,  tY,  tBLx, tY,  1.0);

  // Bottom half arms — fade toward bottomShapeTop
  const bY   = S.bottomShapeTop;
  const bEnd = S.bottomBendStart;
  const bBRx = cx + neckHW + neckBreak;
  const bBLx = cx - neckHW - neckBreak;

  // Bottom-right arm: bright at (right, bottomBendStart), fades toward tip (bBRx, bY)
  drawNeckArm(right, bEnd,  right, bY,  bBRx, bY,  1.0);
  // Bottom-left arm: bright at (left, bottomBendStart), fades toward tip (bBLx, bY)
  drawNeckArm(left,  bEnd,  left,  bY,  bBLx, bY,  1.0);
}

function drawGlass() {
  // 1. Full LED glow on straight edges only
  strokeGlowEdge(buildTopStraightPath);
  strokeGlowEdge(buildBottomStraightPath);

  // 2. Neck arms with smooth fade — no interior fills, no reflections
  drawNeckArms();
  // Background is pure #000000 — no gradients, no reflections, no transparency
}

// ── FOG ───────────────────────────────────────────────────────────────────

function drawTopFog(deltaTime) {
  if (topFillLevel <= 0) return;
  ctx.save();
  buildTopHalfPath(); ctx.clip();
  const { topShapeBottom, left, right } = S;
  const fillH = topShapeBottom * 0.95 * topFillLevel;
  const spanX = (right - left) * 0.46;
  topParticles.forEach((p, i) => {
    p.phase += deltaTime * 0.001;
    const x     = cx + Math.sin(p.phase + i * 0.65) * spanX;
    const baseY = topShapeBottom - (i / topParticles.length) * fillH;
    const rg = ctx.createRadialGradient(x, baseY, 0, x, baseY, p.size);
    rg.addColorStop(0, `rgba(255,255,255,${p.opacity})`);
    rg.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = rg;
    ctx.beginPath(); ctx.arc(x, baseY, p.size, 0, Math.PI * 2); ctx.fill();
  });
  ctx.restore();
}

function drawBottomFog(deltaTime) {
  if (bottomFillLevel <= 0) return;
  ctx.save();
  buildBottomHalfPath(); ctx.clip();
  const { bottomShapeTop, bottom, left, right } = S;
  const fillH = (bottom - bottomShapeTop) * 0.95 * bottomFillLevel;
  const spanX = (right - left) * 0.46;
  bottomParticles.forEach((p, i) => {
    // Only advance phase if actually visible — prevents lag from stale updates
    p.phase += deltaTime * 0.0007;
    const x     = cx + Math.sin(p.phase + i * 0.65) * spanX;
    const baseY = bottom - (i / bottomParticles.length) * fillH;
    const rg = ctx.createRadialGradient(x, baseY, 0, x, baseY, p.size);
    rg.addColorStop(0, `rgba(255,255,255,${p.opacity * 0.9})`);
    rg.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = rg;
    ctx.beginPath(); ctx.arc(x, baseY, p.size, 0, Math.PI * 2); ctx.fill();
  });
  ctx.restore();
}

// ── FLOW PARTICLES ────────────────────────────────────────────────────────
// Particle count and size scale inversely with duration:
//   short timer → many fast small particles (rapid pour)
//   long timer  → fewer slow larger particles (slow trickle)

function spawnFlowParticles() {
  if (flowParticles.length >= MAX_FLOW) return;

  const { neckHW, topShapeBottom } = S;

  const t = Math.max(0, Math.min(1, (duration - MIN_TIME) / (MAX_TIME - MIN_TIME)));
  const spawnCount = Math.round(5 - t * 4); // 5 at 10s → 1 at 60m
  const baseSize   = 5 + t * 14;            // 5px at 10s → 19px at 60m
  const baseSpeed  = 7 - t * 3.5;           // 7 at 10s → 3.5 at 60m

  for (let k = 0; k < spawnCount; k++) {
    // True shotgun: ±150° cone around downward direction
    const spread = (Math.random() - 0.5) * Math.PI * 1.667;
    const angle  = Math.PI / 2 + spread;
    const speed  = baseSpeed * (0.4 + Math.random() * 1.2);
    const sz     = baseSize * (0.6 + Math.random() * 0.9);
    const decay  = 0.004 + (1 - t) * 0.010;

    flowParticles.push({
      x:    cx + (Math.random() - 0.5) * neckHW * 1.4,
      y:    topShapeBottom + 1,
      vx:   Math.cos(angle) * speed,
      vy:   Math.sin(angle) * speed,
      size: sz,
      life: 1.0,
      decay,
    });
  }
}

function drawFlowParticles() {
  for (let i = flowParticles.length - 1; i >= 0; i--) {
    const p = flowParticles[i];
    p.x   += p.vx;
    p.y   += p.vy;
    p.vx  *= 0.997;  // almost no horizontal damping — particles keep flying sideways
    p.vy  += 0.10;   // gravity
    p.life -= p.decay;

    if (p.life <= 0 || p.y > height + 20) {
      flowParticles.splice(i, 1);
      continue;
    }

    const op = Math.max(0, p.life * 0.55);
    const rg = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size);
    rg.addColorStop(0, `rgba(255,255,255,${op})`);
    rg.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = rg;
    ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill();
  }
}

// ── INTERACTION ───────────────────────────────────────────────────────────

function showProgress() {
  progressDisplay.textContent = formatProgress();
  progressDisplay.classList.add('visible');
  isShowingProgress = true;
}

function hideProgress() {
  progressDisplay.classList.remove('visible');
  isShowingProgress = false;
}

function handleStart(e) {
  const clientY = e.touches ? e.touches[0].clientY : e.clientY;

  // Show progress on touch/click in bottom half while running
  if (isRunning && clientY > cy) {
    showProgress();
    return;
  }

  // Drag to set time in top half
  if (clientY < cy) {
    isDragging = true;
    isRunning  = false;
    hideProgress();
    timeDisplay.classList.add('visible');
  }
}

function handleMove(e) {
  const clientY = e.touches ? e.touches[0].clientY : e.clientY;

  if (isDragging) {
    const { topShapeBottom } = S;
    let pct = 1 - (clientY / topShapeBottom);
    topFillLevel    = Math.max(0.01, Math.min(1, pct));
    bottomFillLevel = 0;
    duration        = MIN_TIME + (topFillLevel * (MAX_TIME - MIN_TIME));
    timeLeft        = duration;
    timeDisplay.textContent = formatTime(duration);
    return;
  }

  // Mouse hover: show/hide progress based on position
  if (!e.touches && isRunning) {
    if (clientY > cy) {
      if (!isShowingProgress) showProgress();
      else progressDisplay.textContent = formatProgress();
    } else {
      // Mouse moved out of bottom half → hide immediately
      hideProgress();
    }
  }
}

function handleEnd(e) {
  if (isDragging) {
    isDragging          = false;
    isRunning           = true;
    initialTopFillLevel = topFillLevel;
    timeDisplay.classList.remove('visible');
    lastTime = performance.now();
    return;
  }
  // Touch/click released → always hide progress
  hideProgress();
}

interactionLayer.addEventListener('mousedown', handleStart);
window.addEventListener('mousemove', handleMove);
window.addEventListener('mouseup', handleEnd);
// Hide when mouse leaves the window entirely
window.addEventListener('mouseleave', hideProgress);
// Hide when mouse enters top half (belt-and-suspenders)
canvas.addEventListener('mousemove', e => {
  if (e.clientY <= cy && isShowingProgress) hideProgress();
});
interactionLayer.addEventListener('touchstart', handleStart, { passive: false });
window.addEventListener('touchmove', e => { e.preventDefault(); handleMove(e); }, { passive: false });
// touchend ALWAYS hides progress
window.addEventListener('touchend', e => {
  handleEnd(e);
  hideProgress();
});

// ── ANIMATION LOOP ────────────────────────────────────────────────────────

function animate(now) {
  const deltaTime = Math.min(now - (lastTime || now), 50); // cap at 50ms to avoid jumps
  lastTime = now;

  if (isRunning && timeLeft > 0) {
    const step = deltaTime / 1000;
    timeLeft -= step;
    const rate      = (step / duration) * initialTopFillLevel;
    topFillLevel    = Math.max(0, topFillLevel    - rate);
    bottomFillLevel = Math.min(1, bottomFillLevel + rate);
    if (timeLeft <= 0) {
      isRunning    = false;
      timeLeft     = 0;
      topFillLevel = 0;
      hideProgress();
    }
    if (topFillLevel > 0) spawnFlowParticles();
  }

  // ── Pure black
  ctx.fillStyle = '#000000';
  ctx.fillRect(0, 0, width, height);
  ctx.save(); buildTopHalfPath();    ctx.fillStyle = '#000000'; ctx.fill(); ctx.restore();
  ctx.save(); buildBottomHalfPath(); ctx.fillStyle = '#000000'; ctx.fill(); ctx.restore();

  // ── Fog
  drawTopFog(deltaTime);
  drawBottomFog(deltaTime);

  // ── Flow particles (unclipped)
  drawFlowParticles();

  // ── Glass edges
  drawGlass();

  requestAnimationFrame(animate);
}

init();

// ── WAKE LOCK — keep screen on ────────────────────────────────────────────
let wakeLock = null;

async function requestWakeLock() {
  try {
    if ('wakeLock' in navigator) {
      wakeLock = await navigator.wakeLock.request('screen');
    }
  } catch (e) { /* silently ignore if not supported */ }
}

// Re-acquire wake lock when tab becomes visible again
document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'visible') requestWakeLock();
});

requestWakeLock();
</script>
</body>
</html>