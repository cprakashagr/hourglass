<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">

  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Hourglass">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="theme-color" content="#000000">

  <title>Hourglass</title>
  <style>
    *, *::before, *::after { box-sizing: border-box; }
    body, html {
      margin: 0; padding: 0;
      width: 100%; height: 100%;
      background: #000000;
      overflow: hidden;
      touch-action: none;
      -webkit-tap-highlight-color: transparent;
      font-family: -apple-system, BlinkMacSystemFont, "SF Pro Display", "Helvetica Neue", Arial, sans-serif;
    }
    #canvas-container {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: #000000;
    }
    canvas {
      display: block;
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: #000000;
    }
    #time-display {
      position: absolute;
      color: white; font-size: 2.2rem; font-weight: 200; letter-spacing: 1px;
      opacity: 0; transition: opacity 0.35s ease;
      pointer-events: none;
      text-shadow: 0 0 20px rgba(255,255,255,0.5);
      z-index: 20; text-align: center;
      left: 50%; transform: translateX(-50%);
    }
    #time-display.visible { opacity: 0.95; }
    #progress-display {
      position: absolute;
      color: white; font-size: 1.35rem; font-weight: 300; letter-spacing: 0.5px;
      opacity: 0; transition: opacity 0.25s ease;
      pointer-events: none;
      text-shadow: 0 0 16px rgba(255,255,255,0.45);
      z-index: 20; text-align: center;
      left: 50%; transform: translateX(-50%);
      white-space: nowrap;
    }
    #progress-display.visible { opacity: 0.88; }
    #interaction-layer {
      position: absolute; top: 0; left: 0;
      width: 100%; height: 100%; z-index: 10;
    }

    #landscape-warning {
      display: none;
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: #000; color: #fff; z-index: 1000;
      flex-direction: column; align-items: center; justify-content: center;
      text-align: center; font-size: 1.2rem;
    }
    @media (orientation: landscape) {
      #landscape-warning { display: flex; }
    }
  </style>
</head>
<body>
<div id="landscape-warning">
  <div style="font-size: 3rem; margin-bottom: 20px;">ðŸ“±</div>
  Please rotate to Portrait
</div>
<div id="canvas-container">
  <div id="time-display">10s</div>
  <div id="progress-display"></div>
  <canvas id="glassCanvas"></canvas>
  <div id="interaction-layer"></div>
</div>
<script>
const canvas           = document.getElementById('glassCanvas');
const ctx              = canvas.getContext('2d');
const interactionLayer = document.getElementById('interaction-layer');
const timeDisplay      = document.getElementById('time-display');
const progressDisplay  = document.getElementById('progress-display');

const MIN_TIME = 10;
const MAX_TIME = 3600;

let width, height, cx, cy;
let S = {};

let isDragging          = false;
let isRunning           = false;
let isShowingProgress   = false;
let duration            = 60;
let timeLeft            = 0;
let topFillLevel        = 0;
let initialTopFillLevel = 0;
let bottomFillLevel     = 0;
let lastTime            = 0;

let topParticles    = [];
let bottomParticles = [];
let flowParticles   = [];

const MAX_FLOW = 120;

function init() {
  resize();
  createParticles();
  requestAnimationFrame(animate);
}

function resize() {
  // Use visualViewport if available for more accurate PWA sizing
  width  = window.visualViewport ? window.visualViewport.width : window.innerWidth;
  height = window.visualViewport ? window.visualViewport.height : window.innerHeight;

  const dpr = window.devicePixelRatio || 1;
  canvas.width  = width  * dpr;
  canvas.height = height * dpr;
  canvas.style.width  = width  + 'px';
  canvas.style.height = height + 'px';
  ctx.scale(dpr, dpr);
  cx = width  / 2;
  cy = height / 2;

  const r      = Math.min(44, width * 0.115);
  const neckHW = width * 0.10;
  const bendH  = height * 0.16;
  const gap    = height * 0.019;
  const neckBreak = neckHW * 0.55;

  // CRITICAL FIX: Push the edges out by 10px so they are hidden behind the phone's bezel
  // This removes the "padding" look in the PWA screenshot.
  S = {
    left: -10,
    right: width + 10,
    top: -10,
    bottom: height + 10,
    cx, cy, r, neckHW, bendH, gap, neckBreak,
    topShapeBottom:  cy - gap,
    bottomShapeTop:  cy + gap,
    topBendStart:    cy - gap - bendH,
    bottomBendStart: cy + gap + bendH,
  };

  // Move UI elements safely away from notch and home indicator
  timeDisplay.style.top    = (height * 0.18) + 'px';
  progressDisplay.style.top = (height * 0.82) + 'px';
}
window.addEventListener('resize', resize);

function createParticles() {
  topParticles = Array.from({ length: 160 }, () => ({
    size:    Math.random() * 35 + 24,
    opacity: Math.random() * 0.38 + 0.28,
    phase:   Math.random() * Math.PI * 2
  }));
  bottomParticles = Array.from({ length: 190 }, () => ({
    size:    Math.random() * 38 + 26,
    opacity: Math.random() * 0.38 + 0.28,
    phase:   Math.random() * Math.PI * 2
  }));
}

function formatTime(s) {
  s = Math.max(0, Math.round(s));
  if (s < 60) return s + "s";
  const m = Math.floor(s / 60);
  const sec = s % 60;
  return sec === 0 ? m + "m" : m + "m " + sec + "s";
}

function formatProgress() {
  const elapsed = Math.max(0, duration - timeLeft);
  return formatTime(elapsed) + " of " + formatTime(duration);
}

function buildTopStraightPath() {
  const { left, right, top, r, topBendStart } = S;
  ctx.beginPath();
  ctx.moveTo(left + r, top);
  ctx.lineTo(right - r, top);
  ctx.arcTo(right, top, right, top + r, r);
  ctx.lineTo(right, topBendStart);
  ctx.moveTo(left, topBendStart);
  ctx.lineTo(left, top + r);
  ctx.arcTo(left, top, left + r, top, r);
  ctx.lineTo(right - r, top);
}

function buildBottomStraightPath() {
  const { left, right, bottom, r, bottomBendStart } = S;
  ctx.beginPath();
  ctx.moveTo(right, bottomBendStart);
  ctx.lineTo(right, bottom - r);
  ctx.arcTo(right, bottom, right - r, bottom, r);
  ctx.lineTo(left + r, bottom);
  ctx.arcTo(left, bottom, left, bottom - r, r);
  ctx.lineTo(left, bottomBendStart);
}

function buildTopHalfPath() {
  const { left, right, top, cx, r, neckHW, topShapeBottom, topBendStart } = S;
  ctx.beginPath();
  ctx.moveTo(left + r, top);
  ctx.lineTo(right - r, top);
  ctx.arcTo(right, top, right, top + r, r);
  ctx.lineTo(right, topBendStart);
  ctx.bezierCurveTo(right, topShapeBottom, cx + neckHW, topShapeBottom, cx + neckHW, topShapeBottom);
  ctx.lineTo(cx - neckHW, topShapeBottom);
  ctx.bezierCurveTo(cx - neckHW, topShapeBottom, left, topShapeBottom, left, topBendStart);
  ctx.lineTo(left, top + r);
  ctx.arcTo(left, top, left + r, top, r);
  ctx.closePath();
}

function buildBottomHalfPath() {
  const { left, right, bottom, cx, r, neckHW, bottomShapeTop, bottomBendStart } = S;
  ctx.beginPath();
  ctx.moveTo(cx - neckHW, bottomShapeTop);
  ctx.lineTo(cx + neckHW, bottomShapeTop);
  ctx.bezierCurveTo(cx + neckHW, bottomShapeTop, right, bottomShapeTop, right, bottomBendStart);
  ctx.lineTo(right, bottom - r);
  ctx.arcTo(right, bottom, right - r, bottom, r);
  ctx.lineTo(left + r, bottom);
  ctx.arcTo(left, bottom, left, bottom - r, r);
  ctx.lineTo(left, bottomBendStart);
  ctx.bezierCurveTo(left, bottomShapeTop, cx - neckHW, bottomShapeTop, cx - neckHW, bottomShapeTop);
  ctx.closePath();
}

function strokeGlowEdge(pathFn) {
  ctx.save();
  pathFn();
  ctx.shadowBlur  = 100;
  ctx.shadowColor = 'rgba(160,210,255,0.60)';
  ctx.strokeStyle = 'rgba(0,0,0,0)';
  ctx.lineWidth   = 3;
  ctx.stroke();

  pathFn();
  ctx.shadowBlur  = 55;
  ctx.shadowColor = 'rgba(255,255,255,0.85)';
  ctx.strokeStyle = 'rgba(0,0,0,0)';
  ctx.lineWidth   = 2.5;
  ctx.stroke();

  pathFn();
  ctx.shadowBlur  = 18;
  ctx.shadowColor = 'rgba(255,255,255,1.0)';
  ctx.strokeStyle = 'rgba(255,255,255,0.95)';
  ctx.lineWidth   = 1.8;
  ctx.stroke();

  pathFn();
  ctx.shadowBlur  = 4;
  ctx.shadowColor = 'rgba(255,255,255,1.0)';
  ctx.strokeStyle = 'rgba(255,255,255,1.0)';
  ctx.lineWidth   = 0.8;
  ctx.stroke();
  ctx.restore();
}

function drawNeckArm(x0, y0, cpX, cpY, x1, y1, glowStrength) {
  ctx.save();
  ctx.lineCap = 'round';
  const grLine = ctx.createLinearGradient(x0, y0, x1, y1);
  grLine.addColorStop(0,    `rgba(255,255,255,${0.95 * glowStrength})`);
  grLine.addColorStop(0.35, `rgba(255,255,255,${0.55 * glowStrength})`);
  grLine.addColorStop(0.70, `rgba(255,255,255,${0.18 * glowStrength})`);
  grLine.addColorStop(1,    'rgba(255,255,255,0.00)');

  const grGlow = ctx.createLinearGradient(x0, y0, x1, y1);
  grGlow.addColorStop(0,    `rgba(255,255,255,${0.80 * glowStrength})`);
  grGlow.addColorStop(0.35, `rgba(255,255,255,${0.35 * glowStrength})`);
  grGlow.addColorStop(0.70, `rgba(255,255,255,${0.08 * glowStrength})`);
  grGlow.addColorStop(1,    'rgba(255,255,255,0.00)');

  ctx.shadowBlur  = 30;
  ctx.shadowColor = `rgba(200,230,255,${0.50 * glowStrength})`;
  ctx.strokeStyle = grGlow;
  ctx.lineWidth   = 4;
  ctx.beginPath();
  ctx.moveTo(x0, y0);
  ctx.bezierCurveTo(cpX, cpY, x1, y1, x1, y1);
  ctx.stroke();

  ctx.shadowBlur  = 12;
  ctx.shadowColor = `rgba(255,255,255,${0.80 * glowStrength})`;
  ctx.strokeStyle = grLine;
  ctx.lineWidth   = 1.6;
  ctx.beginPath();
  ctx.moveTo(x0, y0);
  ctx.bezierCurveTo(cpX, cpY, x1, y1, x1, y1);
  ctx.stroke();
  ctx.restore();
}

function drawNeckArms() {
  const { left, right, cx, neckHW, neckBreak } = S;
  const tY = S.topShapeBottom;
  const tEnd = S.topBendStart;
  const tBRx = cx + neckHW + neckBreak;
  const tBLx = cx - neckHW - neckBreak;
  drawNeckArm(right, tEnd, right, tY, tBRx, tY, 1.0);
  drawNeckArm(left, tEnd, left, tY, tBLx, tY, 1.0);

  const bY = S.bottomShapeTop;
  const bEnd = S.bottomBendStart;
  const bBRx = cx + neckHW + neckBreak;
  const bBLx = cx - neckHW - neckBreak;
  drawNeckArm(right, bEnd, right, bY, bBRx, bY, 1.0);
  drawNeckArm(left, bEnd, left, bY, bBLx, bY, 1.0);
}

function drawGlass() {
  strokeGlowEdge(buildTopStraightPath);
  strokeGlowEdge(buildBottomStraightPath);
  drawNeckArms();
}

function drawTopFog(deltaTime) {
  if (topFillLevel <= 0) return;
  ctx.save();
  buildTopHalfPath(); ctx.clip();
  const { topShapeBottom, left, right } = S;
  const fillH = topShapeBottom * 0.95 * topFillLevel;
  const spanX = (right - left) * 0.46;
  topParticles.forEach((p, i) => {
    p.phase += deltaTime * 0.001;
    const x = cx + Math.sin(p.phase + i * 0.65) * spanX;
    const baseY = topShapeBottom - (i / topParticles.length) * fillH;
    const rg = ctx.createRadialGradient(x, baseY, 0, x, baseY, p.size);
    rg.addColorStop(0, `rgba(255,255,255,${p.opacity})`);
    rg.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = rg;
    ctx.beginPath(); ctx.arc(x, baseY, p.size, 0, Math.PI * 2); ctx.fill();
  });
  ctx.restore();
}

function drawBottomFog(deltaTime) {
  if (bottomFillLevel <= 0) return;
  ctx.save();
  buildBottomHalfPath(); ctx.clip();
  const { bottomShapeTop, bottom, left, right } = S;
  const fillH = (bottom - bottomShapeTop) * 0.95 * bottomFillLevel;
  const spanX = (right - left) * 0.46;
  bottomParticles.forEach((p, i) => {
    p.phase += deltaTime * 0.0007;
    const x = cx + Math.sin(p.phase + i * 0.65) * spanX;
    const baseY = bottom - (i / bottomParticles.length) * fillH;
    const rg = ctx.createRadialGradient(x, baseY, 0, x, baseY, p.size);
    rg.addColorStop(0, `rgba(255,255,255,${p.opacity * 0.9})`);
    rg.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = rg;
    ctx.beginPath(); ctx.arc(x, baseY, p.size, 0, Math.PI * 2); ctx.fill();
  });
  ctx.restore();
}

function spawnFlowParticles() {
  if (flowParticles.length >= MAX_FLOW) return;
  const { neckHW, topShapeBottom } = S;
  const t = Math.max(0, Math.min(1, (duration - MIN_TIME) / (MAX_TIME - MIN_TIME)));
  const spawnCount = Math.round(5 - t * 4);
  const baseSize   = 5 + t * 14;
  const baseSpeed  = 7 - t * 3.5;
  for (let k = 0; k < spawnCount; k++) {
    const spread = (Math.random() - 0.5) * Math.PI * 1.667;
    const angle  = Math.PI / 2 + spread;
    const speed  = baseSpeed * (0.4 + Math.random() * 1.2);
    const sz     = baseSize * (0.6 + Math.random() * 0.9);
    const decay  = 0.004 + (1 - t) * 0.010;
    flowParticles.push({
      x:    cx + (Math.random() - 0.5) * neckHW * 1.4,
      y:    topShapeBottom + 1,
      vx:   Math.cos(angle) * speed,
      vy:   Math.sin(angle) * speed,
      size: sz,
      life: 1.0,
      decay,
    });
  }
}

function drawFlowParticles() {
  for (let i = flowParticles.length - 1; i >= 0; i--) {
    const p = flowParticles[i];
    p.x += p.vx; p.y += p.vy; p.vy += 0.10; p.life -= p.decay;
    if (p.life <= 0 || p.y > height + 20) { flowParticles.splice(i, 1); continue; }
    const op = Math.max(0, p.life * 0.55);
    const rg = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size);
    rg.addColorStop(0, `rgba(255,255,255,${op})`);
    rg.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = rg;
    ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill();
  }
}

function handleStart(e) {
  const y = e.touches ? e.touches[0].clientY : e.clientY;
  if (isRunning && y > cy) { progressDisplay.textContent = formatProgress(); progressDisplay.classList.add('visible'); isShowingProgress = true; return; }
  if (y < cy) { isDragging = true; isRunning = false; progressDisplay.classList.remove('visible'); timeDisplay.classList.add('visible'); }
}

function handleMove(e) {
  const y = e.touches ? e.touches[0].clientY : e.clientY;
  if (isDragging) {
    let pct = 1 - (y / S.topShapeBottom);
    topFillLevel = Math.max(0.01, Math.min(1, pct));
    bottomFillLevel = 0;
    duration = MIN_TIME + (topFillLevel * (MAX_TIME - MIN_TIME));
    timeLeft = duration;
    timeDisplay.textContent = formatTime(duration);
  }
}

function handleEnd() {
  if (isDragging) { isDragging = false; isRunning = true; initialTopFillLevel = topFillLevel; timeDisplay.classList.remove('visible'); lastTime = performance.now(); }
  progressDisplay.classList.remove('visible'); isShowingProgress = false;
}

interactionLayer.addEventListener('mousedown', handleStart);
window.addEventListener('mousemove', handleMove);
window.addEventListener('mouseup', handleEnd);
interactionLayer.addEventListener('touchstart', handleStart, { passive: false });
window.addEventListener('touchmove', e => { e.preventDefault(); handleMove(e); }, { passive: false });
window.addEventListener('touchend', handleEnd);

function animate(now) {
  const deltaTime = Math.min(now - (lastTime || now), 50);
  lastTime = now;
  if (isRunning && timeLeft > 0) {
    const step = deltaTime / 1000;
    timeLeft -= step;
    const rate = (step / duration) * initialTopFillLevel;
    topFillLevel = Math.max(0, topFillLevel - rate);
    bottomFillLevel = Math.min(1, bottomFillLevel + rate);
    if (timeLeft <= 0) { isRunning = false; timeLeft = 0; topFillLevel = 0; }
    if (topFillLevel > 0) spawnFlowParticles();
  }
  ctx.fillStyle = '#000000';
  ctx.fillRect(0, 0, width, height);
  drawTopFog(deltaTime);
  drawBottomFog(deltaTime);
  drawFlowParticles();
  drawGlass();
  requestAnimationFrame(animate);
}

init();

let wakeLock = null;
async function requestWakeLock() {
  try { if ('wakeLock' in navigator) wakeLock = await navigator.wakeLock.request('screen'); } catch (e) {}
}
document.addEventListener('visibilitychange', () => { if (document.visibilityState === 'visible') requestWakeLock(); });
requestWakeLock();
</script>
</body>
</html>
